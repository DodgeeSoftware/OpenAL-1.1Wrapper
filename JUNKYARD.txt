


//////// LIBSNDFILE Load PCM DATA Code Start
//    std::string filename = "media/sounds/682865_Trainwreck-of-Electro-Swin.ogg"; // No Clicks
//    //std::string filename = "media/sounds/Victory_Fanfare.ogg"; // Clicks
//    //std::string filename = "media/sounds/level05.ogg"; // Clicks
//    //std::string filename = "media/sounds/hit.wav"; // No click
//    SF_INFO info;
//    SNDFILE* file = sf_open(filename.c_str(), SFM_READ, &info);
//
//    std::cout << sf_strerror(file) << std::endl;
//
//    std::cout << "Sample Rate: " << info.samplerate << std::endl;
//    std::cout << "Channels: " << info.channels << std::endl;
//    std::cout << "Format: " << info.format << std::endl;
//    std::cout << "Frames: " << info.frames << std::endl;
//
//
//    std::vector<int16_t> readBuffer;
//        readBuffer.resize(4096);
//    std::vector<int16_t> data;
//    size_t readSize = 0;
//    while((readSize = sf_read_short(file, readBuffer.data(), readBuffer.size())) != 0)
//    {
//        data.insert(data.end(), readBuffer.begin(), readBuffer.begin() + readSize);
//    }
//    std::cout << "Size of Data: " << data.size() << std::endl;
//
//    ALuint buffer;
//    ALsizei frequency = 44100;
//    ALenum format = AL_FORMAT_STEREO16;
//
//    alGenBuffers(1, &buffer);
//    alBufferData(buffer, format, (void*)data.data(), data.size() * 2.0, info.samplerate); // WHY: For some reason it only works with twice the data >.>
//
//    ALuint source;
//    alGenSources(1, &source);
//    alSourcei(source, AL_BUFFER, buffer);
//    alSourcePlay(source);
//    alSourcei(source, AL_LOOPING, AL_TRUE);
//
//    // LISTENER
//    // Set Listener Position
//    float playerX = 0.0f;
//    float playerY = 0.0f;
//    float playerZ = 0.0f;
//    alListener3f(AL_ORIENTATION, playerX, playerY, playerZ);
//    //// Set Listener Direction
//    //float direction[6];
//    //direction[0] = cos(listnerAngle);
//    //direction[1] = 0.0f;
//    //direction[2] = sin(listnerAngle);
//    //direction[3] = 0.0f;
//    //direction[4] = 1.0f;
//    //direction[5] = 0.0f;
//    //alListener3f(AL_ORIENTATION, direction);


//    alSourceStop(source);
//    alDeleteSources(1, &source);
//////// LIBSNDFILE Load PCM DATA Code End


//    ///////  XMP TRACKER EXAMPLE START
//    xmp_context context = xmp_create_context();
//    //if (xmp_load_module(context, "media/music/Level1 - not used.mod") < 0)
//    //if (xmp_load_module(context, "media/music/Level1.mod") < 0)
//    //if (xmp_load_module(context, "media/music/Level2.mod") < 0)
//    if (xmp_load_module(context, "media/music/Level3.mod") < 0)
//    //if (xmp_load_module(context, "media/music/Level4.mod") < 0)
//    //if (xmp_load_module(context, "media/music/level5.mod") < 0)
//    {
//        std::cout << "ERROR: Failed to load music module file" << std::endl;
//        return -1;
//    }
//    std::cout << "NOTICE: Successful Opened Tracker File" << std::endl;
//    std::cout << std::endl;
//
//    //xmp_start_player(context, 44100, 0);
//    xmp_start_player(context, 22050, 0);
//
//
//    xmp_module_info info;
//    xmp_get_module_info(context, &info);
//    std::cout << "NAME: " << info.mod->name << " TYPE: " << info.mod->type << std::endl;
//    std::cout << "BPM: " << info.mod->bpm << " CHANNELS: " << info.mod->chn << std::endl;
//    std::cout << "INSTRUMENTS: " << info.mod->ins << " LENGTH: " << info.mod->len << std::endl;
//
//
//
//
//    ALuint buffer[NUM_BUFFERS];
//    alGenBuffers(NUM_BUFFERS, &buffer[0]);
//
//    xmp_frame_info frameInfo;
//    for (int i = 0; i < NUM_BUFFERS; i++)
//    {
//        xmp_play_frame(context);
//        xmp_get_frame_info(context, &frameInfo);
//        //alBufferData(buffer[i], AL_FORMAT_STEREO16, frameInfo.buffer, frameInfo.buffer_size, 44100);
//        alBufferData(buffer[i], AL_FORMAT_STEREO16, frameInfo.buffer, frameInfo.buffer_size, 22050);
//    }
//
//    ALuint source;
//    alGenSources(1, &source);
//    alSourceQueueBuffers(source, NUM_BUFFERS, &buffer[0]);
//
//    alSourcePlay(source);
//
//
//    while (xmp_play_frame(context) == 0)
//    {
//        ALuint bbuffer;
//
//        ALint val;
//
//        alGetSourcei(source, AL_BUFFERS_PROCESSED, &val);
//        while (val <= 0) {
//            alGetSourcei(source, AL_BUFFERS_PROCESSED, &val);
//        }
//
//        xmp_get_frame_info(context, &frameInfo);
//
//        if (frameInfo.loop_count > 0)
//            break;
//
//        alSourceUnqueueBuffers(source, 1, &bbuffer);
//
//        //alBufferData(bbuffer, AL_FORMAT_STEREO16, frameInfo.buffer, frameInfo.buffer_size, 44100);
//        alBufferData(bbuffer, AL_FORMAT_STEREO16, frameInfo.buffer, frameInfo.buffer_size, 22050);
//
//        alSourceQueueBuffers(source, 1, &bbuffer);
//
//        alGetSourcei(source, AL_SOURCE_STATE, &val);
//        if (val != AL_PLAYING)
//            alSourcePlay(source);
//    }
//
//    xmp_end_player(context);
//    xmp_release_module(context);
//    xmp_free_context(context);
//    ///////  XMP TRACKER EXAMPLE END
